<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GanSO - Jogo de Tabuleiro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary': '#121212',
                        'secondary': '#1E88E5',
                        'accent': '#03A9F4',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #121212;
            color: white;
        }

        .board-cell {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            font-weight: bold;
            position: relative;
        }

        .player-token {
            position: absolute;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            border: 2px solid #121212;
            transform: translate(-50%, -50%);
            top: 50%;
            left: 50%;
            transition: all 0.5s ease-in-out;
        }
        
        .rolling {
            animation: roll 1s ease-out;
        }

        @keyframes roll {
            0% { transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg); }
            100% { transform: rotateX(720deg) rotateY(720deg) rotateZ(720deg); }
        }

        .roll-message {
            animation: fade-in 0.5s ease-in-out;
        }

        @keyframes fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .animate-pulse-slow {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        .stars .fa-star {
            color: #ccc;
        }
        .stars .text-yellow-400 {
            color: #FACC15;
        }

        .modal {
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
        }
        .player-color-indicator {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            border: 2px solid #121212;
            margin-right: 8px;
        }
        .player-turn-indicator-color {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            border: 2px solid #121212;
        }
        .player-turn-indicator-text {
            text-align: center;
        }
    </style>
</head>
<body class="bg-primary text-gray-200 min-h-screen flex flex-col items-center p-4">
    <div id="setup-screen" class="container mx-auto px-4 py-8 max-w-md bg-gray-900 rounded-xl shadow-lg border border-gray-700 text-center">
        <h1 class="text-4xl font-bold text-accent mb-6">GanSO</h1>
        <p class="text-lg mb-4">Escolha a quantidade de jogadores:</p>
        <div class="flex flex-col items-center space-y-4 mb-6">
            <input type="number" id="player-count-input" value="1" min="1" max="10" class="bg-gray-800 text-white text-center py-2 px-4 rounded-lg w-24">
            <button id="start-game-btn" class="bg-secondary hover:bg-accent text-white font-bold py-2 px-6 rounded-full shadow-lg transition-transform duration-200 transform hover:scale-105">Iniciar Jogo</button>
        </div>
    </div>
    
    <div id="game-screen" class="container mx-auto px-4 py-8 max-w-4xl bg-gray-900 rounded-xl shadow-lg border border-gray-700 hidden">
        <header class="text-center mb-6">
            <h1 class="text-4xl font-bold text-accent mb-2">GanSO</h1>
            <h2 class="text-xl text-white" id="round-info">Rodada: 1 | Vez do Jogador 1</h2>
        </header>

        <div id="board" class="grid grid-cols-10 gap-2 mb-6">
            </div>

        <div id="players-status" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
            </div>
        
        <div id="action-section" class="text-center mb-6 flex flex-col items-center space-y-4">
            <div id="player-turn-indicator" class="flex justify-center items-center space-x-2 text-xl font-semibold text-white">
                </div>
            <div id="dice-container" class="w-24 h-24 bg-gray-800 rounded-xl flex items-center justify-center text-6xl font-bold text-white shadow-lg transition-transform duration-200 transform">
                ?
            </div>
            <p id="roll-message" class="text-3xl font-bold text-accent roll-message"></p>
            <div class="flex justify-center items-center space-x-4">
                <button id="stay-put-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold w-32 h-12 flex items-center justify-center rounded-lg shadow-lg transition-transform duration-200 transform hover:scale-105 active:scale-95">
                    Ficar Parado
                </button>
                <button id="roll-dice-btn" class="bg-secondary hover:bg-accent text-white font-bold w-32 h-12 flex items-center justify-center rounded-lg shadow-lg transition-transform duration-200 transform hover:scale-105 active:scale-95">
                    Rolar Dado
                </button>
            </div>
        </div>
        
        <div id="game-message-container" class="text-center p-4 rounded-lg mb-6 text-gray-300">
            <p id="game-message" class="text-lg">Processo em Execução.</p>
        </div>

        <div id="answerModal" class="fixed inset-0 flex items-center justify-center hidden modal">
            <div class="bg-gray-800 rounded-lg p-6 w-full max-w-md border border-gray-700 shadow-xl relative">
                <h2 id="difficulty-text" class="text-center font-semibold text-lg mb-2"></h2>
                <p class="text-lg mb-4 text-center" id="action-prompt"></p>
                
                <p id="answer-text" class="text-center text-yellow-300 mb-4 hidden p-2 bg-gray-700 rounded"></p>
                
                <div id="show-answer-container" class="flex justify-center mb-4">
                    <button id="show-answer-btn" class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg transition-transform duration-200 transform hover:scale-105">Ver Resposta</button>
                </div>
                
                <div id="judgment-buttons" class="flex justify-center space-x-4 hidden">
                    <button id="correct-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition-transform duration-200 transform hover:scale-105">Acertou!</button>
                    <button id="wrong-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition-transform duration-200 transform hover:scale-105">Errou</button>
                </div>
                
                <button id="reroll-dice-btn-modal" class="absolute bottom-2 right-2 bg-purple-600 hover:bg-purple-700 text-white font-bold w-24 h-10 flex items-center justify-center rounded-lg shadow-lg transition-transform duration-200 transform hover:scale-105 active:scale-95 text-sm">
                    Rejogar
                </button>
            </div>
        </div>
        
        <div class="mt-8">
            <h3 class="text-lg font-semibold text-secondary mb-2">Log de Eventos</h3>
            <div id="log" class="bg-gray-800 rounded-lg p-4 h-48 overflow-y-auto text-sm text-gray-400 border border-gray-700">
            </div>
        </div>
    </div>

    <script>
        const gameData = {
            players: [],
            currentPlayerIndex: 0,
            round: 1,
            lastRoll: 0,
            boardDifficulty: [],
            currentResourceCost: { cpu: 0, ram: 0 },
            currentQuestion: null, // Adicionado para guardar a pergunta/resposta atual
            questions: {
                facil: [
                    { question: "O que significa a sigla SO?", answer: "Sistema Operacional." },
                    { question: "Cite um exemplo de sistema operacional.", answer: "Windows, Linux, macOS, Android, iOS." },
                    { question: "Qual empresa desenvolve o Windows?", answer: "Microsoft." },
                    { question: "O Linux é de código aberto ou fechado?", answer: "Código aberto (Open Source)." },
                    { question: "O que é um arquivo em um sistema operacional?", answer: "Uma coleção de dados armazenada em um dispositivo de armazenamento." },
                    { question: "O que é um diretório?", answer: "Uma estrutura para organizar arquivos, também conhecida como pasta." },
                    { question: "Cite um sistema operacional de smartphone.", answer: "Android ou iOS." },
                    { question: "Qual tecla no Windows abre o Gerenciador de Tarefas junto com Ctrl+Alt?", answer: "Delete (Del)." },
                    { question: "O que é memória RAM usada pelo SO?", answer: "Memória de acesso aleatório, usada para armazenar dados temporários de programas em execução." },
                    { question: "O que acontece quando ligamos o computador?", answer: "Ocorre o processo de boot, onde o SO é carregado na memória." },
                    { question: "O que significa a sigla CPU?", answer: "Central Processing Unit (Unidade Central de Processamento)." },
                    { question: "O que é um processo?", answer: "Um programa em execução." },
                    { question: "No Linux, o diretório raiz é representado por qual símbolo?", answer: "A barra ( / )." },
                    { question: "Cite um exemplo de chamada de sistema.", answer: "open(), read(), write(), fork()." },
                    { question: "Qual sistema operacional vem nos celulares da Apple?", answer: "iOS." },
                    { question: "O que significa a sigla I/O?", answer: "Input/Output (Entrada/Saída)." },
                    { question: "O que é um driver no SO?", answer: "Um software que permite que o SO se comunique com um dispositivo de hardware." },
                    { question: "Qual comando é usado no Windows para listar arquivos em um diretório?", answer: "dir." },
                    { question: "Qual comando é usado no Linux para listar arquivos?", answer: "ls." },
                    { question: "O que é um kernel?", answer: "O núcleo do sistema operacional, responsável por gerenciar os recursos do sistema." },
                    { question: "Cite uma operação básica que pode ser feita em um arquivo.", answer: "Criar, ler, escrever, deletar." },
                    { question: "Qual a função de um antivírus em relação ao SO?", answer: "Proteger o sistema contra malwares e softwares maliciosos." },
                    { question: "O que é um backup?", answer: "Uma cópia de segurança dos dados." },
                    { question: "Cite um exemplo de sistema de arquivos.", answer: "NTFS, FAT32, ext4, APFS." },
                    { question: "O que significa login em um sistema operacional?", answer: "O processo de autenticação para acessar o sistema." }
                ],
                medio: [
                    { question: "Qual a diferença entre hardware e software?", answer: "Hardware é a parte física do computador; Software são os programas e dados." },
                    { question: "O que significa que um SO é multitarefa?", answer: "Ele pode executar vários processos (tarefas) simultaneamente." },
                    { question: "Qual a função principal do sistema de arquivos?", answer: "Organizar e gerenciar como os dados são armazenados e recuperados em um disco." },
                    { question: "O que significa a sigla PCB (Process Control Block)?", answer: "Bloco de Controle de Processo, uma estrutura de dados que armazena informações sobre um processo." },
                    { question: "Cite dois exemplos de sistemas de arquivos.", answer: "NTFS e ext4." },
                    { question: "Qual a diferença entre memória volátil e não volátil?", answer: "Volátil (RAM) perde os dados sem energia; Não volátil (HD/SSD) mantém os dados." },
                    { question: "O que é um dispositivo de entrada? Cite um exemplo.", answer: "Um dispositivo que envia dados para o computador. Ex: teclado, mouse." },
                    { question: "O que é um dispositivo de saída? Cite um exemplo.", answer: "Um dispositivo que recebe dados do computador. Ex: monitor, impressora." },
                    { question: "O que é uma interrupção em SO?", answer: "Um sinal que interrompe a CPU para atender a um evento urgente de hardware ou software." },
                    { question: "O que é login e senha em um sistema?", answer: "Credenciais usadas para autenticar um usuário e permitir seu acesso." },
                    { question: "O que significa read, write, execute (rwx) em arquivos?", answer: "Permissões de arquivo: Ler (read), Escrever (write) e Executar (execute)." },
                    { question: "No Linux, o que é um soft link?", answer: "Um atalho ou ponteiro para outro arquivo, similar a um atalho do Windows." },
                    { question: "No Linux, o que é um hard link?", answer: "Uma segunda entrada de diretório para o mesmo arquivo (inode)." },
                    { question: "O que é fragmentação em um disco?", answer: "Quando um arquivo é dividido em pedaços não contíguos no disco, tornando o acesso mais lento." },
                    { question: "Cite duas funções da cache de disco.", answer: "Acelerar o acesso a dados lidos frequentemente e melhorar o desempenho de escrita." },
                    { question: "Qual a função do MBR (Master Boot Record)?", answer: "Contém a tabela de partições e o código de inicialização para carregar o SO." },
                    { question: "O que é um quantum no escalonamento Round Robin?", answer: "A fatia de tempo (time slice) que cada processo pode usar a CPU antes de ser preemptado." },
                    { question: "Qual a diferença entre FIFO e SJF?", answer: "FIFO (First-In, First-Out) executa processos na ordem de chegada. SJF (Shortest Job First) executa o processo mais curto primeiro." },
                    { question: "O que é um deadlock?", answer: "Uma situação em que dois ou mais processos ficam bloqueados, esperando por recursos que os outros detêm." },
                    { question: "O que é o dispatcher em um sistema operacional?", answer: "O módulo que dá o controle da CPU ao processo selecionado pelo escalonador." },
                    { question: "Cite três operações básicas em arquivos.", answer: "Criar, deletar, abrir, fechar, ler, escrever." },
                    { question: "O que é memória virtual?", answer: "Uma técnica que usa o disco rígido para simular mais memória RAM do que a fisicamente disponível." },
                    { question: "Cite um método de alocação de arquivos no disco.", answer: "Alocação Contígua, Encadeada ou Indexada." },
                    { question: "O que significa o conceito de partição em discos?", answer: "Dividir um disco físico em uma ou mais seções lógicas." },
                    { question: "O que é multithreading?", answer: "A capacidade de um processo dividir a si mesmo em múltiplas threads (linhas de execução) que podem ser executadas concorrentemente." }
                ],
                dificil: [
                    { question: "Explique a diferença entre processo e programa.", answer: "Programa é um conjunto de instruções passivas em disco. Processo é um programa em execução, uma entidade ativa." },
                    { question: "Diferencie kernel monolítico e microkernel.", answer: "Monolítico tem todos os serviços do SO no mesmo espaço de endereço (kernel space). Microkernel tem apenas serviços essenciais, com outros rodando como processos de usuário." },
                    { question: "Explique como funciona a memória virtual com paginação.", answer: "A memória é dividida em páginas (lógica) e quadros (física). Uma tabela de páginas mapeia endereços virtuais para físicos, permitindo que partes de um processo fiquem em disco." },
                    { question: "O que é thrashing em memória virtual?", answer: "É quando o sistema passa mais tempo trocando páginas entre a RAM e o disco do que executando processos, devido à falta de memória." },
                    { question: "Descreva como funciona o algoritmo de substituição de páginas LRU.", answer: "LRU (Least Recently Used) substitui a página que não foi usada por mais tempo, assumindo que ela tem menor probabilidade de ser usada novamente." },
                    { question: "O que significa context switch e por que ele é custoso?", answer: "É a troca da CPU de um processo para outro. É custoso porque envolve salvar o estado do processo atual e carregar o estado do próximo, um trabalho puramente administrativo (overhead)." },
                    { question: "Diferencie escalonamento preemptivo e não preemptivo.", answer: "Preemptivo: o SO pode forçar a troca de processos (ex: por tempo). Não preemptivo: um processo só libera a CPU quando termina ou se bloqueia." },
                    { question: "Quais são os três níveis de escalonamento (longo, médio, curto)?", answer: "Longo prazo (decide quais processos entram na memória), Médio prazo (swapping) e Curto prazo (seleciona o próximo processo para a CPU)." },
                    { question: "Qual a diferença entre prioridade estática e dinâmica em escalonamento?", answer: "Estática: a prioridade é fixa. Dinâmica: a prioridade pode mudar durante a execução do processo (ex: aging)." },
                    { question: "Como funciona o Round Robin e qual seu problema principal?", answer: "Cada processo recebe uma fatia de tempo (quantum). O problema é definir o tamanho ideal do quantum: muito grande vira FIFO, muito pequeno aumenta o overhead de context switch." },
                    { question: "Explique o problema de starvation.", answer: "Inanição. Um processo de baixa prioridade pode nunca ser executado se sempre houver processos de maior prioridade prontos." },
                    { question: "Como o aging resolve o problema de starvation?", answer: "Aumenta gradualmente a prioridade de processos que estão esperando há muito tempo na fila de prontos." },
                    { question: "Explique como funciona a alocação contígua de arquivos no disco.", answer: "Cada arquivo ocupa um conjunto contíguo de blocos no disco. É simples e rápido, mas sofre de fragmentação externa." },
                    { question: "Explique como funciona a alocação encadeada de arquivos no disco.", answer: "Cada bloco de arquivo contém um ponteiro para o próximo bloco. Resolve a fragmentação externa, mas não permite acesso direto." },
                    { question: "Explique como funciona a alocação indexada de arquivos no disco.", answer: "Usa um bloco de índice (inode) que contém ponteiros para todos os blocos de dados do arquivo. Permite acesso direto e resolve a fragmentação." },
                    { question: "O que é o VFS (Virtual File System)?", answer: "Uma camada de abstração no kernel que fornece uma interface uniforme para diferentes tipos de sistemas de arquivos." },
                    { question: "Qual a função das tabelas TDAA e TAAP em arquivos abertos?", answer: "TDAA (Tabela de Descritores de Arquivos Abertos) é por processo. TAAP (Tabela de Arquivos Abertos do Processo) é global. Elas gerenciam os arquivos em uso." },
                    { question: "Diferencie os métodos de acesso a arquivos sequencial e relativo.", answer: "Sequencial: os dados são lidos em ordem, um após o outro. Relativo (ou direto): é possível ler/escrever em qualquer bloco do arquivo diretamente." },
                    { question: "O que é um descritor de arquivo?", answer: "Um número inteiro (índice) que identifica um arquivo aberto para um processo." },
                    { question: "Diferencie um sistema batch de um sistema time-sharing.", answer: "Batch executa jobs em lote, sem interação do usuário. Time-sharing (tempo compartilhado) permite que múltiplos usuários interajam com o sistema simultaneamente." },
                    { question: "O que são as condições de Coffman para deadlock?", answer: "Exclusão mútua, posse e espera, não preempção e espera circular. Todas as quatro devem ocorrer para um deadlock existir." },
                    { question: "Explique o papel do dispatcher no chaveamento de contexto.", answer: "O dispatcher é o módulo que efetivamente realiza a troca de contexto, dando o controle da CPU para o processo escolhido pelo escalonador." },
                    { question: "Quais são os principais objetivos do escalonamento de processos?", answer: "Maximizar o uso da CPU, maximizar a vazão (throughput), minimizar o tempo de resposta, minimizar o tempo de espera e garantir justiça (fairness)." },
                    { question: "Explique a diferença entre multithreading em nível de usuário e em nível de kernel.", answer: "Nível de usuário: o kernel não sabe das threads, são gerenciadas pela aplicação. Nível de kernel: o kernel gerencia as threads, permitindo que múltiplas threads de um processo rodem em múltiplos núcleos." }
                ]
            },
            discardPiles: {
                facil: [],
                medio: [],
                dificil: []
            },
            playerColors: ["bg-red-500", "bg-blue-500", "bg-green-500", "bg-yellow-500", "bg-purple-500", "bg-pink-500", "bg-indigo-500", "bg-teal-500", "bg-orange-500", "bg-cyan-500"],
            playersPlayedInRound: []
        };
        
        const rollDiceBtn = document.getElementById('roll-dice-btn');
        const stayPutBtn = document.getElementById('stay-put-btn');
        const diceContainer = document.getElementById('dice-container');
        const rollMessageEl = document.getElementById('roll-message');
        const answerModal = document.getElementById('answerModal');
        const difficultyTextEl = document.getElementById('difficulty-text');
        const actionPromptEl = document.getElementById('action-prompt');
        const correctBtn = document.getElementById('correct-btn');
        const wrongBtn = document.getElementById('wrong-btn');
        const logEl = document.getElementById('log');
        const gameMessageEl = document.getElementById('game-message');
        const roundInfoEl = document.getElementById('round-info');
        const boardEl = document.getElementById('board');
        const playersStatusEl = document.getElementById('players-status');
        const setupScreen = document.getElementById('setup-screen');
        const gameScreen = document.getElementById('game-screen');
        const startGameBtn = document.getElementById('start-game-btn');
        const playerCountInput = document.getElementById('player-count-input');
        const playerTurnIndicatorEl = document.getElementById('player-turn-indicator');
        const rerollDiceModalBtn = document.getElementById('reroll-dice-btn-modal');

        // Novos seletores para o modal modificado
        const showAnswerBtn = document.getElementById('show-answer-btn');
        const answerTextEl = document.getElementById('answer-text');
        const judgmentButtons = document.getElementById('judgment-buttons');
        const showAnswerContainer = document.getElementById('show-answer-container');
        
        function addLog(message, color = 'text-gray-400') {
            const entry = document.createElement('p');
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            entry.className = `mt-1 ${color}`;
            logEl.prepend(entry);
            if (logEl.childElementCount > 20) {
                logEl.removeChild(logEl.lastChild);
            }
        }
        
        function getDifficultyColor(difficulty) {
            switch (difficulty) {
                case 'facil': return 'bg-green-600';
                case 'medio': return 'bg-yellow-600';
                case 'dificil': return 'bg-red-600';
                default: return 'bg-gray-600';
            }
        }

        function createBoard() {
            boardEl.innerHTML = '';
            gameData.boardDifficulty = [];
            for (let i = 1; i <= 30; i++) {
                let randomDifficulty;
                if (i === 30) {
                    randomDifficulty = 'final';
                } else {
                    const difficulties = ['facil', 'medio', 'dificil'];
                    randomDifficulty = difficulties[Math.floor(Math.random() * difficulties.length)];
                }
                gameData.boardDifficulty[i] = randomDifficulty;

                const cell = document.createElement('div');
                cell.id = `cell-${i}`;
                let cellColor = getDifficultyColor(randomDifficulty);
                if (i === 30) {
                    cellColor = 'bg-blue-500';
                }
                cell.className = `board-cell text-white ${cellColor}`;
                cell.innerHTML = `<span>${i}</span>`;
                boardEl.appendChild(cell);
            }
        }

        function createPlayerStatus() {
            playersStatusEl.innerHTML = '';
            gameData.players.forEach(player => {
                const playerDiv = document.createElement('div');
                playerDiv.className = `bg-gray-800 rounded-lg p-2 mb-2 border border-gray-700`;
                playerDiv.innerHTML = `
                    <div class="flex items-center mb-2">
                        <div class="player-color-indicator ${player.color} mr-2"></div>
                        <span class="font-bold text-sm sm:text-base">${player.name}</span>
                        <span class="ml-auto text-xs sm:text-sm" id="pos-${player.id}">Posição: ${player.position}/30</span>
                    </div>
                    <div class="flex space-x-2">
                        <div class="flex-1">
                            <span class="text-xs sm:text-sm">CPU:</span>
                            <div class="w-full h-2 bg-gray-700 rounded-full">
                                <div id="cpu-bar-${player.id}" class="h-2 bg-green-500 rounded-full transition-all duration-500" style="width: ${player.cpu}%;"></div>
                            </div>
                            <span id="cpu-text-${player.id}" class="text-xs ml-2">${player.cpu}%</span>
                        </div>
                        <div class="flex-1">
                            <span class="text-xs sm:text-sm">RAM:</span>
                            <div class="w-full h-2 bg-gray-700 rounded-full">
                                <div id="ram-bar-${player.id}" class="h-2 bg-green-500 rounded-full transition-all duration-500" style="width: ${player.ram}%;"></div>
                            </div>
                            <span id="ram-text-${player.id}" class="text-xs ml-2">${player.ram}%</span>
                        </div>
                    </div>
                `;
                playersStatusEl.appendChild(playerDiv);
            });
        }
        
        function updatePlayerPosition() {
            const playersOnBoard = document.querySelectorAll('.player-token');
            playersOnBoard.forEach(token => token.remove());

            gameData.players.forEach(player => {
                const cell = document.getElementById(`cell-${player.position}`);
                if (cell) {
                    const token = document.createElement('div');
                    token.className = `player-token ${player.color}`;
                    token.id = `player-${player.id}-token`;
                    cell.appendChild(token);
                }
            });
        }

        function freeOldResources(player) {
            const resourcesToFree = player.resourceQueue.filter(resource => gameData.round - resource.round >= 5);
            
            if (resourcesToFree.length > 0) {
                const cpuLib = resourcesToFree.reduce((sum, res) => sum + res.cpu, 0);
                const ramLib = resourcesToFree.reduce((sum, res) => sum + res.ram, 0);
                addLog(`Recursos da rodada ${gameData.round - 5} liberados: ${Math.round(cpuLib)}% CPU e ${Math.round(ramLib)}% RAM.`, 'text-lime-400');
            }
            
            player.resourceQueue = player.resourceQueue.filter(resource => gameData.round - resource.round < 5);
        }

        function updatePlayerUI() {
            gameData.players.forEach(player => {
                const cpuBar = document.getElementById(`cpu-bar-${player.id}`);
                const ramBar = document.getElementById(`ram-bar-${player.id}`);
                const cpuText = document.getElementById(`cpu-text-${player.id}`);
                const ramText = document.getElementById(`ram-text-${player.id}`);
                const posText = document.getElementById(`pos-${player.id}`);

                const totalCpu = player.resourceQueue.reduce((sum, res) => sum + res.cpu, 0);
                const totalRam = player.resourceQueue.reduce((sum, res) => sum + res.ram, 0);

                player.cpu = Math.max(0, Math.min(100, Math.round(totalCpu)));
                player.ram = Math.max(0, Math.min(100, Math.round(totalRam)));

                if (cpuBar) cpuBar.style.width = `${player.cpu}%`;
                if (ramBar) ramBar.style.width = `${player.ram}%`;
                if (cpuText) cpuText.textContent = `${player.cpu}%`;
                if (ramText) ramText.textContent = `${player.ram}%`;
                if (posText) posText.textContent = `Posição: ${player.position}/30`;

                if (cpuBar) {
                    if (player.cpu >= 70) cpuBar.classList.replace('bg-green-500', 'bg-red-500');
                    else cpuBar.classList.replace('bg-red-500', 'bg-green-500');
                }

                if (ramBar) {
                    if (player.ram >= 70) ramBar.classList.replace('bg-green-500', 'bg-red-500');
                    else ramBar.classList.replace('bg-red-500', 'bg-green-500');
                }
            });

            const currentPlayer = gameData.players[gameData.currentPlayerIndex];
            if (roundInfoEl) roundInfoEl.textContent = `Rodada: ${gameData.round} | Vez do Jogador ${currentPlayer.id}`;
            
            const isAnsweringQuestion = answerModal && !answerModal.classList.contains('hidden');
            
            if (rollDiceBtn) rollDiceBtn.disabled = isAnsweringQuestion;
            if (stayPutBtn) stayPutBtn.disabled = isAnsweringQuestion;

            if (gameMessageEl) {
                if (currentPlayer.cpu >= 100 || currentPlayer.ram >= 100) {
                    if (rollDiceBtn) rollDiceBtn.disabled = true;
                    if (stayPutBtn) stayPutBtn.disabled = false;
                    let resource = '';
                    if (currentPlayer.cpu >= 100 && currentPlayer.ram >= 100) {
                        resource = 'CPU e RAM';
                    } else if (currentPlayer.cpu >= 100) {
                        resource = 'CPU';
                    } else {
                        resource = 'RAM';
                    }
                    gameMessageEl.textContent = `${resource} no limite! Próximo consumo pode causar um deadlock.`;
                } else if (currentPlayer.cpu > 100 || currentPlayer.ram > 100) {
                    if (rollDiceBtn) rollDiceBtn.disabled = true;
                    if (stayPutBtn) stayPutBtn.disabled = false;
                    gameMessageEl.textContent = 'Recursos esgotados! Processo bloqueado. Use "Ficar Parado" para liberar recursos.';
                } else if (!isAnsweringQuestion) {
                    gameMessageEl.textContent = 'Sua vez de jogar. Escolha uma ação!';
                }
            }

            if(playerTurnIndicatorEl) {
                const color = gameData.players[gameData.currentPlayerIndex].color;
                playerTurnIndicatorEl.innerHTML = `
                    <div class="flex items-center space-x-2 text-xl font-semibold text-white">
                        <span>Jogador ${currentPlayer.id}</span>
                        <div class="player-turn-indicator-color ${color}"></div>
                    </div>
                `;
            }
        }
        
        const rollDice = () => {
            const currentPlayer = gameData.players[gameData.currentPlayerIndex];
            
            if (currentPlayer.cpu >= 100 || currentPlayer.ram >= 100) {
                if (gameMessageEl) {
                    let message = '';
                    if (currentPlayer.cpu >= 100 && currentPlayer.ram >= 100) {
                        message = 'CPU e RAM no limite! Libere recursos para continuar.';
                    } else if (currentPlayer.cpu >= 100) {
                        message = 'CPU no limite! Libere recursos para continuar.';
                    } else {
                        message = 'RAM no limite! Libere recursos para continuar.';
                    }
                    gameMessageEl.textContent = message;
                }
                return;
            }

            if (diceContainer) {
                diceContainer.textContent = '?';
                diceContainer.classList.add('rolling');
            }
            
            setTimeout(() => {
                const roll = Math.floor(Math.random() * 6) + 1;
                if (diceContainer) {
                    diceContainer.classList.remove('rolling');
                    diceContainer.textContent = roll;
                }
                if (rollMessageEl) rollMessageEl.textContent = `Resultado do dado do Jogador ${currentPlayer.id}: ${roll}`;
                gameData.lastRoll = roll;
                addLog(`Jogador ${currentPlayer.id} rolou o dado. Resultado: ${roll}`);
                
                processTurn(roll);

            }, 1000);
        };
        
        const processTurn = (roll) => {
            const currentPlayer = gameData.players[gameData.currentPlayerIndex];
            const nextPosition = currentPlayer.position + roll;
            
            if (nextPosition >= 30) {
                currentPlayer.position = 30;
                updatePlayerPosition();
                addLog(`Parabéns, Jogador ${currentPlayer.id}! Você finalizou o processo e venceu a corrida!`, 'text-blue-400');
                if (gameMessageEl) gameMessageEl.textContent = `Fim de jogo! Jogador ${currentPlayer.id} venceu!`;
                rollDiceBtn.disabled = true;
                stayPutBtn.disabled = true;
                return;
            }

            const difficulty = gameData.boardDifficulty[nextPosition];
            
            const qa = drawQuestion(difficulty);
            
            if (!qa) {
                addLog(`Nenhuma pergunta disponível para dificuldade ${difficulty}. Passando a vez.`, 'text-yellow-400');
                passTurn();
                return;
            }

            gameData.currentQuestion = qa;

            if (difficultyTextEl) difficultyTextEl.textContent = `Pergunta (${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}):`;
            if (actionPromptEl) actionPromptEl.textContent = qa.question;

            // Resetar e mostrar o modal no estado inicial
            answerTextEl.classList.add('hidden');
            showAnswerContainer.classList.remove('hidden');
            judgmentButtons.classList.add('hidden');
            if (answerModal) answerModal.classList.remove('hidden');

            correctBtn.disabled = false;
            wrongBtn.disabled = false;
            rerollDiceModalBtn.disabled = false;
            
            currentPlayer.currentDifficulty = difficulty;
            
            addLog(`Jogador ${currentPlayer.id} puxou uma carta de dificuldade: ${difficulty}.`);
            updatePlayerUI();
        };

        const drawQuestion = (difficulty) => {
            let pile = gameData.questions[difficulty];
            let discardPile = gameData.discardPiles[difficulty];

            if (pile.length === 0) {
                addLog('Pilha de perguntas vazia! Reabastecendo e embaralhando.');
                gameData.questions[difficulty] = discardPile.sort(() => Math.random() - 0.5);
                gameData.discardPiles[difficulty] = [];
                pile = gameData.questions[difficulty];
            }

            if (pile.length > 0) {
                const randomIndex = Math.floor(Math.random() * pile.length);
                const questionObject = pile.splice(randomIndex, 1)[0];
                discardPile.push(questionObject);
                return questionObject;
            }
            return null; // Retorna null se não houver perguntas
        };

        const handleAnswer = (isCorrect) => {
            const currentPlayer = gameData.players[gameData.currentPlayerIndex];
            const { cpu, ram } = getResourceCosts(currentPlayer.currentDifficulty);
            
            const currentCpu = currentPlayer.resourceQueue.reduce((sum, res) => sum + res.cpu, 0);
            const currentRam = currentPlayer.resourceQueue.reduce((sum, res) => sum + res.ram, 0);

            if (currentCpu + cpu > 100 || currentRam + ram > 100) {
                addLog('Falta de recursos!', 'text-red-400');
                if (answerModal) answerModal.classList.add('hidden');
                
                passTurn();
                return;
            }
            
            currentPlayer.resourceQueue.push({ round: gameData.round, cpu, ram });
            addLog(`Consumo de recursos: +${cpu}% CPU e +${ram}% RAM.`);

            if (isCorrect) {
                currentPlayer.position += gameData.lastRoll;
                addLog(`Jogador ${currentPlayer.id} acertou a pergunta! Avançou ${gameData.lastRoll} casas.`, 'text-green-400');
            } else {
                currentPlayer.position = Math.max(0, currentPlayer.position - 1);
                addLog(`Jogador ${currentPlayer.id} errou a pergunta! Voltou 1 casa (rollback).`, 'text-red-400');
            }
            
            currentPlayer.position = Math.min(currentPlayer.position, 30);
            updatePlayerPosition();

            if (currentPlayer.position >= 30) {
                addLog(`Parabéns, Jogador ${currentPlayer.id}! Você finalizou o processo e venceu a corrida!`, 'text-blue-400');
                if (gameMessageEl) gameMessageEl.textContent = `Fim de jogo! Jogador ${currentPlayer.id} venceu!`;
                rollDiceBtn.disabled = true;
                stayPutBtn.disabled = true;
            } else {
                passTurn();
            }
            
            if (answerModal) answerModal.classList.add('hidden');
            updatePlayerUI();
        };

        const handleStayPut = () => {
            const currentPlayer = gameData.players[gameData.currentPlayerIndex];
            
            let currentCpu = currentPlayer.resourceQueue.reduce((sum, res) => sum + res.cpu, 0);
            let currentRam = currentPlayer.resourceQueue.reduce((sum, res) => sum + res.ram, 0);

            const cpuFreed = Math.round(Math.min(currentCpu, 20));
            const ramFreed = Math.round(Math.min(currentRam, 30));
            
            if (cpuFreed > 0 || ramFreed > 0) {
                addLog(`Jogador ${currentPlayer.id} ficou parado! Liberou recursos: -${cpuFreed}% CPU e -${ramFreed}% RAM.`, 'text-blue-400');
                currentPlayer.resourceQueue.push({ round: gameData.round, cpu: -cpuFreed, ram: -ramFreed });
            } else {
                addLog(`Jogador ${currentPlayer.id} tentou ficar parado, mas não havia recursos para liberar.`, 'text-yellow-400');
            }
            
            passTurn();
            updatePlayerUI();
        };
        
        const handleRerollDice = () => {
            const currentPlayer = gameData.players[gameData.currentPlayerIndex];
            const cpuCost = 30;
            const currentCpu = currentPlayer.resourceQueue.reduce((sum, res) => sum + res.cpu, 0);

            if (currentCpu + cpuCost > 100) {
                addLog('Falta de recursos!', 'text-red-400');
                if (answerModal) answerModal.classList.add('hidden');
                 
                passTurn();
                return;
            }
            
            currentPlayer.resourceQueue.push({ round: gameData.round, cpu: cpuCost, ram: 0 });
            addLog(`Jogador ${currentPlayer.id} rejogou o dado. Custo: +${cpuCost}% CPU.`, 'text-purple-400');
            
            if (answerModal) answerModal.classList.add('hidden');
            
            updatePlayerUI();
            rollDice();
        };

        const getResourceCosts = (difficulty) => {
            switch (difficulty) {
                case 'facil': return { cpu: 30, ram: 20 };
                case 'medio': return { cpu: 25, ram: 25 };
                case 'dificil': return { cpu: 20, ram: 30 };
                default: return { cpu: 0, ram: 0 };
            }
        };

        const passTurn = () => {
             gameData.playersPlayedInRound.push(gameData.currentPlayerIndex);
             if (gameData.playersPlayedInRound.length >= gameData.players.length) {
                 gameData.playersPlayedInRound = [];
                 gameData.round++;
                 addLog(`Nova rodada iniciada: ${gameData.round}`, 'text-blue-400');
                 gameData.players.forEach(p => freeOldResources(p));
             }
             do {
                 gameData.currentPlayerIndex = (gameData.currentPlayerIndex + 1) % gameData.players.length;
             } while (gameData.playersPlayedInRound.includes(gameData.currentPlayerIndex));
             updatePlayerUI();
        };

        const initGame = (playerCount) => {
            gameData.players = [];
            for (let i = 0; i < playerCount; i++) {
                gameData.players.push({
                    id: i + 1,
                    name: `Jogador ${i + 1}`,
                    color: gameData.playerColors[i % gameData.playerColors.length],
                    position: 0,
                    cpu: 0,
                    ram: 0,
                    resourceQueue: []
                });
            }
            if (setupScreen) setupScreen.classList.add('hidden');
            if (gameScreen) gameScreen.classList.remove('hidden');
            
            createBoard();
            createPlayerStatus();
            updatePlayerPosition();
            updatePlayerUI();
            addLog('Início do jogo! Processos prontos para executar.');
        };
        
        // Evento para o novo botão "Ver Resposta"
        if (showAnswerBtn) {
            showAnswerBtn.addEventListener('click', () => {
                if (gameData.currentQuestion) {
                    answerTextEl.textContent = `Resposta: ${gameData.currentQuestion.answer}`;
                    answerTextEl.classList.remove('hidden');
                    showAnswerContainer.classList.add('hidden');
                    judgmentButtons.classList.remove('hidden');
                }
            });
        }
        
        if (startGameBtn) {
            startGameBtn.addEventListener('click', () => {
                const playerCount = parseInt(playerCountInput.value);
                if (playerCount >= 1 && playerCount <= 10) {
                    initGame(playerCount);
                } else {
                    alert("Por favor, escolha entre 1 a 10 jogadores.");
                }
            });
        }

        if (rollDiceBtn) rollDiceBtn.addEventListener('click', rollDice);
        if (stayPutBtn) stayPutBtn.addEventListener('click', handleStayPut);
        if (rerollDiceModalBtn) rerollDiceModalBtn.addEventListener('click', handleRerollDice);
        if (correctBtn) correctBtn.addEventListener('click', () => handleAnswer(true));
        if (wrongBtn) wrongBtn.addEventListener('click', () => handleAnswer(false));
    </script>
</body>
</html>

